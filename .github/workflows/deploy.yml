name: Deploy PlacementPro Full Stack to AWS EC2

on:
  push:
    branches: [ main ]

jobs:
  # This job performs a basic check on the Python code.
  test:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt

    - name: Test FastAPI app
      run: |
        python -c "from main import app; print('âœ… App loads successfully')"

  # This job builds the Docker image and deploys it to the EC2 instance.
  deploy:
    needs: test
    runs-on: ubuntu-latest
    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
    steps:
    - uses: actions/checkout@v3

    - name: Clean up Docker space on runner
      run: |
        echo "ğŸ§¹ Cleaning up disk space on GitHub runner..."
        docker system prune -af || true

    - name: Build and push Docker image
      run: |
        echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
        echo "ğŸ³ Building complete PlacementPro image..."
        docker build -t "$DOCKER_USERNAME/placementpro:latest" .
        echo "ğŸ“¤ Pushing Docker image..."
        docker push "$DOCKER_USERNAME/placementpro:latest"
        echo "âœ… Docker image pushed successfully"

    # Create the deployment script
    - name: Create deployment script
      run: |
        cat > deploy.sh << 'EOL'
        #!/bin/bash
        echo "ğŸ§¹ Cleaning up disk space on EC2 instance..."
        sudo docker system prune -af --volumes
        sudo journalctl --vacuum-time=2d
        df -h

        set -e
        cd /home/ec2-user/placementpro || (mkdir -p /home/ec2-user/placementpro && cd /home/ec2-user/placementpro)

        echo "ğŸ›‘ Stopping and removing old container and processes..."
        sudo docker stop placementpro 2>/dev/null || true
        sudo docker rm placementpro 2>/dev/null || true
        for port in 3000 5000 8000 80; do
          sudo lsof -ti:$port | xargs -r sudo kill -9 2>/dev/null || true
        done

        echo "ğŸ“¥ Pulling latest Docker image..."
        sudo docker pull $1/placementpro:latest

        mkdir -p temp static/reports static/summaries static/transcripts

        echo "ğŸš€ Starting new PlacementPro container..."
        sudo docker run -d \
          --name placementpro \
          -p 80:3000 \
          -p 3000:3000 \
          -p 5000:5000 \
          -p 8000:8000 \
          -v $(pwd)/temp:/app/temp \
          -v $(pwd)/static:/app/static \
          --restart unless-stopped \
          --memory="3g" \
          --cpus="2.0" \
          $1/placementpro:latest

        if [ $? -ne 0 ]; then
          echo "âŒ Container failed to start. Checking logs and port conflicts..."
          sudo lsof -i:3000 || echo "Port 3000 is free"
          sudo lsof -i:5000 || echo "Port 5000 is free"
          sudo lsof -i:8000 || echo "Port 8000 is free"
          sudo docker logs placementpro 2>/dev/null || echo "No logs available for failed container."
          exit 1
        fi

        echo "â³ Waiting for container to become healthy..."
        for i in {1..15}; do
          HEALTH_STATUS=$(sudo docker inspect --format '{{.State.Health.Status}}' placementpro)
          if [ "$HEALTH_STATUS" = "healthy" ]; then
            echo "âœ… Container is healthy!"
            break
          fi
          echo "Container status is '$HEALTH_STATUS'. Waiting... (Attempt $i/15)"
          sleep 10
          if [ $i -eq 15 ]; then
            echo "âŒ Container did not become healthy in time."
            sudo docker logs placementpro --tail 50
            exit 1
          fi
        done

        echo "ğŸ§ª Testing all services..."
        # Backend health check
        echo "ğŸ”§ Testing Backend API..."
        for i in {1..10}; do
          if curl -f -s http://localhost:8000/api/health > /dev/null; then
            echo "âœ… Backend API: Working!"
            break
          fi
          echo "â³ Backend API attempt $i/10..."
          sleep 10
          if [ $i -eq 10 ]; then
            echo "âŒ Backend API failed after 10 attempts"
            sudo docker logs placementpro --tail 50
            exit 1
          fi
        done

        # Frontend health check
        echo "ğŸ¨ Testing Frontend..."
        for i in {1..8}; do
          if curl -f -s http://localhost:3000 > /dev/null; then
            echo "âœ… Frontend: Working!"
            break
          fi
          echo "â³ Frontend attempt $i/8..."
          sleep 15
        done

        # Chat server health check
        echo "ğŸ’¬ Testing Chat Server..."
        for i in {1..5}; do
          # We just check if the port is open, as websockets might not return a simple 200 OK
          if nc -z localhost 5000; then
            echo "âœ… Chat Server: Port is open!"
            break
          fi
          echo "â³ Chat server attempt $i/5..."
          sleep 10
          if [ $i -eq 5 ]; then
            echo "âš ï¸ Chat Server did not respond."
          fi
        done

        echo ""
        echo "ğŸ“Š Final deployment status:"
        echo "ğŸ³ Container Status:"
        sudo docker ps --filter name=placementpro --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
        echo ""
        echo "ğŸ“ˆ Resource Usage:"
        sudo docker stats placementpro --no-stream --format "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"
        echo ""
        echo "ğŸ“‹ Recent Service Logs:"
        sudo docker logs placementpro --tail 20

        echo ""
        echo "ğŸ‰ Complete PlacementPro platform deployed successfully!"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "ğŸŒ MAIN WEBSITE: http://$2"
        echo "ğŸ“– API Documentation: http://$2:8000/docs"
        echo "ğŸ¥ Health Check: http://$2:8000/api/health"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        EOL
        chmod +x deploy.sh

    # Deploy using SSH with a more reliable action
    - name: Deploy to EC2
      uses: easingthemes/ssh-deploy@main
      with:
        SSH_PRIVATE_KEY: ${{ secrets.EC2_PRIVATE_KEY }}
        REMOTE_HOST: ${{ secrets.EC2_HOST }}
        REMOTE_USER: ec2-user
        SOURCE: "deploy.sh"
        TARGET: "/home/ec2-user"
        SCRIPT_AFTER: "cd /home/ec2-user && bash deploy.sh ${{ secrets.DOCKER_USERNAME }} ${{ secrets.EC2_HOST }}"
